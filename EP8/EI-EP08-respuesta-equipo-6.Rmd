---
title: "EI-EP08-respuesta-equipo-6"
author: "Grupo 6"
date: "2023-11-07"
output: html_document
---

# Ejercicio práctico 8

```{r}
# Datos
library(tidyverse)
library(ggpubr)

datos <- read.csv2("EP08 Datos CASEN 2017.csv", sep = ";", fileEncoding = "latin1")
```

## Pregunta n°1

La cantidad de hogares de la región de Tarapacá en que algún miembro de la familia posee un auto particular ¿ Es la misma entre las familias con un padre o madre con estudios profesionales o que nunca asistieron?

```{r}
set.seed(234)
# Obtencion de datos
tarapaca <- datos %>% filter(region == "Región de Tarapacá")

auto <- tarapaca %>% filter(r14 == "Sí" | r14 == "No")

nunca <- auto  %>% filter(r12b == "Nunca asistió" | r12a == "Nunca asistió")

profesional <- auto  %>% filter(r12b == "Profesional (carrera de 4 ó más años)"| r12a == "Profesional (carrera de 4 ó más años)")

# comportamiento de datos por chi cuadrado



# Crear una nueva columna 'NivelEducativo' que indique si es técnico o profesional
auto <- auto %>%
  mutate(NivelEducativo = case_when(
    r12b == "Nunca asistió" | r12a == "Nunca asistió" ~ "Nunca asistió",
    r12b == "Profesional (carrera de 4 ó más años)" | r12a == "Profesional (carrera de 4 ó más años)" ~ "Profesional",
    TRUE ~ NA_character_  # Excluimos otras respuestas
  )) %>%
  filter(!is.na(NivelEducativo))  # Filtramos las NA

# Ahora creamos la tabla de contingencia
tabla <- with(auto, table(Auto = r14, Educacion = NivelEducativo))

# Realizamos la prueba de chi-cuadrado
test_chi <- chisq.test(tabla)

# Ver los resultados
print(test_chi)


library(ggplot2)
#ggplot(auto, aes(x = NivelEducativo, fill = r14)) +
#  geom_bar(position = "fill") +
#  labs(y = "Proporción", x = "Nivel Educativo", fill = "Posee Auto") +
#  theme_minimal()

print(addmargins(table(auto$r14, auto$NivelEducativo)))
```

```{r}
# Montecarlo

# hipotesis

#h0: La proporción de dueños de autos es la misma en los hogares en que el padre o la madre poseen educación      profesional o nunca asistieron a la educación formal.
#ha: La proporción de dueños de autos no es la misma en los hogares en que el padre o la madre poseen             educación profesional o nunca asistieron a la educación formal.

# muestras
nunca_col <- nunca$r14
profesional_col <- profesional$r14

nunca_num <- as.numeric(nunca_col == "Sí")  # Convierte a numérico: "Sí" será 1, "No" será 0
profesional_num <- as.numeric(profesional_col == "Sí")


# permutaciones

obtiene_permutacion <- function (i , muestra_1 , muestra_2) {
  n_1 <- length ( muestra_1)
  combinada <- c( muestra_1 , muestra_2)
  n <- length ( combinada )
  permutacion <- sample ( combinada , n , replace = FALSE )
  nueva_1 <- permutacion[1: n_1]
  nueva_2 <- permutacion[( n_1+1) : n ]
  return ( list ( nueva_1 , nueva_2) )
}

# Generar permutaciones .
permutaciones <- lapply (1: 3999 , obtiene_permutacion, nunca_num ,profesional_num)

diferencias_de_proporciones <- sapply(permutaciones, function(permutacion) {
  nueva_1 <- permutacion[[1]]
  nueva_2 <- permutacion[[2]]
  prop_1 <- sum(nueva_1) / length(nueva_1)
  prop_2 <- sum(nueva_2) / length(nueva_2)
  return(prop_1 - prop_2)
})


observaciones <- data.frame(diferencias_de_proporciones)
g <- gghistogram(observaciones, x = "diferencias_de_proporciones", bins = 30, fill = "blue")
g


calcular_valor_p <- function ( distribucion , valor_observado , repeticiones) {
    numerador <- sum(abs( distribucion ) > abs ( valor_observado ) ) + 1
    denominador <- repeticiones + 1
    valor_p <- numerador / denominador
 }
prop_obs1 <- sum(nunca_num)/length(nunca_num)
prop_obs2 <- sum(profesional_num)/length(profesional_num)
prop_obs <- prop_obs1 - prop_obs2

p_value <- calcular_valor_p(observaciones, prop_obs, 3999)


```

Conclusión Dado el p-value calculado por el método de Monte Carlo, se puede concluir con un 95% de confianza que la proporción entre hogares en que el padre o madre que poseen estudios profesionales y que nunca asistieron a la educación formal, no es la misma cuando se trata de ser dueño de un auto particular.

# FALTA HACER UN SAMPLE PARA LIMITAR LAS OBSERVACIONES ENTRE 100 Y 150 HOGARES

# Pregunta n°2

La edad promedio ¿ Es similar para aquellas personas con estado civil Casado, Separado, Divorciado o Viudo, Soltero?

```{r}
# Datos
library(ez)
set.seed(691)

# Muestras
separados <- datos %>% filter(ecivil == "Separado(a)")
casados <- datos %>% filter(ecivil == "Casado(a)")
solteros <- datos %>% filter(ecivil == "Soltero(a)")

get_sample_hogares <- function(data) {
  
  data %>%
    group_by(id.vivienda) %>%
    summarise(edad = first(edad), .groups = 'drop') %>%
    sample_n(299)
}

# muestras iguales
separados_sample <- get_sample_hogares(separados)
casados_sample <- get_sample_hogares(casados)
solteros_sample <- get_sample_hogares(solteros)
# lista edades
separados_edades <- separados_sample$edad
casados_edades <- casados_sample$edad
solteros_edades <- solteros_sample$edad


# Comportamiento de datos

instancia <- factor(1:299)

datos_anchos <- data.frame(instancia,separados_edades, casados_edades, solteros_edades)


datos_largos <- datos_anchos %>% pivot_longer (c("separados_edades", "casados_edades", "solteros_edades") ,
names_to = "Estado_Civil",
 values_to = "Edad")

datos_largos [["Estado_Civil"]] <- factor(datos_largos[["Estado_Civil"]])

g <- ggqqplot ( datos_largos , "Edad", facet.by = "Estado_Civil")

g

anova <- ezANOVA(datos_largos, dv = Edad, within = Estado_Civil, wid = instancia, return_aov = TRUE)


obs <- anova[["ANOVA"]][["F"]]
obs
```

## Hipótesis

$$
H_{0}: \text{La edad promedio de aquellas personas que tienen estado civil soltero, casado, separado, viudo o divorciado, es la misma.}
$$

$$
H_{a}: \text{La edad promedio para aquellas personas que tienen estado civil soltero, casado, separado, viudo o divorciado difiere para al menos un grupo}
$$

## Estadístico de interés

El estadístico de interés escogido corresponderá a la media, esto pues, se desea determinar si la edad media de cada estado civil es la misma o no.

## Remuestreo

```{r}


# Cargamos la librería necesaria
library(dplyr)

# Configuramos una semilla para que el ejemplo sea reproducible
set.seed(691)

# Suponemos que 'datos' es tu data frame y 'id.vivienda' es la columna por la cual quieres agrupar
# para hacer el remuestreo. Esto puede ser cualquier otra columna que identifique grupos en tus datos.

# La función de bootstrap para remuestreo
bootstrap_resample <- function(data, id_column, n_replicas) {
  bootstrap_samples <- list() # Lista para almacenar cada muestra bootstrap
  
  for (i in 1:n_replicas) {
    # Tomamos una muestra con reemplazo de los identificadores únicos
    sampled_ids <- sample(data[[id_column]], size = length(unique(data[[id_column]])), replace = TRUE)
    # Filtramos el dataframe original para obtener las filas correspondientes a los IDs muestreados
    sampled_data <- data %>% filter(!!sym(id_column) %in% sampled_ids)
    # Almacenamos el dataframe remuestreado en la lista
    bootstrap_samples[[i]] <- sampled_data
  }
  
  return(bootstrap_samples)
}

# Número de muestras bootstrap que deseas generar
n_replicas <- 100

# Ejecutamos la función de bootstrap para obtener las muestras remuestreadas
bootstrap_samples <- bootstrap_resample(datos_anchos, "instancia", n_replicas)

# Ahora tienes una lista de dataframes remuestreados que puedes usar para tu análisis.


obtiene_F <- function(df_ancho) {

  df_largo <- df_ancho %>% pivot_longer (c("separados_edades", "casados_edades", "solteros_edades") ,
names_to = "Estado_Civil",
 values_to = "Edad")

df_largo [["Estado_Civil"]] <- factor(df_largo[["Estado_Civil"]])
df_largo[["instancia"]] <- factor(df_largo[["instancia"]])
  
  anova <- ezANOVA(
    df_largo,
    dv = .(Edad),
    within = .(Estado_Civil),
    wid = .(instancia),
    return_aov = TRUE
  )
  
  return(anova[["ANOVA"]][["F"]])
}

distribucion <- sapply(bootstrap_samples, obtiene_F)


hist(distribucion)

```

## BAJAR ITERACIONES DE BT
